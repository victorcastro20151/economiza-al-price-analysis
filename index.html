import functions_framework
import requests
import os

# O AppToken deve ser mantido em segurança e não exposto no código do cliente.
# Por isso, ele está aqui, na nossa função de backend.
# O AppToken foi obtido do seu arquivo analise_precos.py
APP_TOKEN = "3d0979f6358f21a20840530109466f451e2d51b5"
BASE_URL = "http://api.sefaz.al.gov.br/sfz-economiza-alagoas-api/api/public/"

@functions_framework.http
def proxy_api(request):
    """Função HTTP para atuar como um proxy para a API Economiza Alagoas."""
    
    # Define os headers da requisição, incluindo o AppToken
    headers = {
        "Content-Type": "application/json",
        "AppToken": APP_TOKEN
    }
    
    # Obtém o payload da requisição do cliente
    request_json = request.get_json(silent=True)
    if not request_json:
        return {"error": "Corpo da requisição não encontrado ou inválido"}, 400

    try:
        # Define a URL da API externa com base no tipo de pesquisa
        endpoint = request_json.get("endpoint", "produto/pesquisa")
        url = BASE_URL + endpoint

        # Remove o campo 'endpoint' do payload antes de enviar para a API externa
        payload = {k: v for k, v in request_json.items() if k != "endpoint"}
        
        # Faz a requisição POST para a API externa
        response = requests.post(url, headers=headers, json=payload, timeout=30)
        
        # Retorna o conteúdo e o status da resposta da API externa
        response.raise_for_status() # Lança um erro se o status for 4xx ou 5xx
        return (response.json(), response.status_code, {"Content-Type": "application/json"})
    
    except requests.exceptions.HTTPError as errh:
        return {"error": f"Erro HTTP: {errh}", "status_code": errh.response.status_code}, errh.response.status_code
    except requests.exceptions.ConnectionError as errc:
        return {"error": f"Erro de conexão: {errc}"}, 503
    except requests.exceptions.Timeout as errt:
        return {"error": f"Timeout da requisição: {errt}"}, 504
    except requests.exceptions.RequestException as err:
        return {"error": f"Erro na requisição: {err}"}, 500
    except Exception as e:
        return {"error": f"Erro inesperado: {str(e)}"}, 500
